---
title: AllJoynCodeGen 概述
author: saraclay
ms.author: saclayt
ms.date: 09/06/17
ms.topic: article
ms.prod: windows-iot
ms.technology: IoT
description: 了解有关 AllJoynCodeGen，代码生成工具生成一个完整的 Windows 运行时组件使用 AllJoyn 接口的信息。
keywords: windows iot AllJoyn
ms.openlocfilehash: c8e9f08c5565c7e4252e1b15858c08402eedb712
ms.sourcegitcommit: ef85ccba54b1118d49554e88768240020ff514b0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/11/2019
ms.locfileid: "59510976"
---
> [!NOTE]
> <span data-ttu-id="e0873-104">你正在查看存档的文档。</span><span class="sxs-lookup"><span data-stu-id="e0873-104">You are viewing archived documentation.</span></span> <span data-ttu-id="e0873-105">Windows 10 IoT 不再支持 AllJoyn。</span><span class="sxs-lookup"><span data-stu-id="e0873-105">AllJoyn is no longer supported by Windows 10 IoT.</span></span> <span data-ttu-id="e0873-106">如有问题，请打开在 GitHub 上或在下面的注释中留下反馈。</span><span class="sxs-lookup"><span data-stu-id="e0873-106">For questions, please open an issue on GitHub or leave us feedback in the comments below.</span></span>

# <a name="alljoyncodegen-overview"></a><span data-ttu-id="e0873-107">AllJoynCodeGen 概述</span><span class="sxs-lookup"><span data-stu-id="e0873-107">AllJoynCodeGen Overview</span></span>

<span data-ttu-id="e0873-108">我们创建了代码生成工具 AllJoynCodeGen，该工具可使用派生自某种规范或某台设备的一个或多个 AllJoyn 接口的 XML 描述生成完整的 Windows 运行时组件。</span><span class="sxs-lookup"><span data-stu-id="e0873-108">We've created a code generation tool, AllJoynCodeGen, that generates a complete Windows Runtime component using an XML description of one or more AllJoyn interfaces derived from a specification or device.</span></span>

<span data-ttu-id="e0873-109">由此工具生成的 Windows 运行时组件通过使用通用 Windows SDK 中提供的 API，可在任何受支持的语言（JS、C#、C++/CX 等）中使用。</span><span class="sxs-lookup"><span data-stu-id="e0873-109">The Windows Runtime component generated by this tool can be consumed in any supported language (JS, C#, C++/CX, etc.) using APIs that are available in the Universal Windows SDK.</span></span> <span data-ttu-id="e0873-110">这表示相同的组件可在具有 AllJoyn OneCore 程序包（路由器服务和 C API dll）的任何平台上使用。然后，开发人员可使用该组件创建该接口的制造者和/或使用者。</span><span class="sxs-lookup"><span data-stu-id="e0873-110">This means that the same component can be used on any platform that has the AllJoyn OneCore package (router service and C API dll.) A developer can then use the component to create a producer and/or a consumer of that interface.</span></span> 

<span data-ttu-id="e0873-111">**请注意**对于有关 AllJoyn C Api 的更多详细信息，您可以下载 AllJoyn Core SDK 和文档，网址[AllSeen 联盟](http://go.microsoft.com/fwlink/?LinkId=524584)。</span><span class="sxs-lookup"><span data-stu-id="e0873-111">**Note**  For more details about the AllJoyn C APIs, you can download the AllJoyn Core SDK and documentation at [The AllSeen Alliance](http://go.microsoft.com/fwlink/?LinkId=524584).</span></span>

## <a name="how-does-alljoyncodegen-work"></a><span data-ttu-id="e0873-112">AllJoynCodeGen 是如何工作的？</span><span class="sxs-lookup"><span data-stu-id="e0873-112">How does AllJoynCodeGen work?</span></span>

<span data-ttu-id="e0873-113">基本流程如下所示：</span><span class="sxs-lookup"><span data-stu-id="e0873-113">The basic flow is as follows:</span></span>

1. <span data-ttu-id="e0873-114">以 AllJoyn XML 编写（当前为 DBus 内省格式）、描述服务的 XML 文件会被送入代码生成器工具中。</span><span class="sxs-lookup"><span data-stu-id="e0873-114">An XML file authored in the AllJoyn XML (currently DBus introspection format) that describes the service is fed into the codegen tool.</span></span>
2. <span data-ttu-id="e0873-115">AllJoynCodeGen 工具将生成结果为 Windows 运行时组件的代码。</span><span class="sxs-lookup"><span data-stu-id="e0873-115">The AllJoynCodeGen tool generates code that results in a Windows Runtime component.</span></span> <span data-ttu-id="e0873-116">此生成的代码依赖于 Windows 10 SDK 中的 **MSAJAPI.lib** 和 [Windows.Devices.AllJoyn](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.alljoyn.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e0873-116">This generated code relies on **MSAJAPI.lib** and [Windows.Devices.AllJoyn](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.alljoyn.aspx) from the Windows 10 SDK.</span></span>
3. <span data-ttu-id="e0873-117">开发人员可生成使用此组件的应用程序。</span><span class="sxs-lookup"><span data-stu-id="e0873-117">The developer builds an application that consumes this component.</span></span>
4. <span data-ttu-id="e0873-118">运行时，开发人员的应用程序将加载该工具生成的 Windows 运行时组件（例如：foo.dll）以及内置 DLL **MSAJAPI.dll** 和 **Windows.Devices.AllJoyn.dll**。</span><span class="sxs-lookup"><span data-stu-id="e0873-118">At runtime, the developer's application will load the Windows Runtime component generated by the tool (e.g.: foo.dll,) as well as the in-box DLLs **MSAJAPI.dll** and **Windows.Devices.AllJoyn.dll**.</span></span>

<span data-ttu-id="e0873-119">以下工作流图表说明了这一过程：</span><span class="sxs-lookup"><span data-stu-id="e0873-119">The following workflow diagram illustrates this process:</span></span>

![AllJoyn CodeGen 图](../media/AllJoyn/alljoyncodegen.png)

## <a name="running-from-the-command-line"></a><span data-ttu-id="e0873-121">从命令行运行</span><span class="sxs-lookup"><span data-stu-id="e0873-121">Running from the command line</span></span>

<span data-ttu-id="e0873-122">AllJoynCodeGen 工具当前作为随 Windows 10 SDK 提供的命令行工具的形式存在。</span><span class="sxs-lookup"><span data-stu-id="e0873-122">The AllJoynCodeGen tool currently exists as a command line tool shipped with the Windows 10 SDK.</span></span> <span data-ttu-id="e0873-123">若要运行该工具，请使用以下字符串传递有效的 XML 文件：</span><span class="sxs-lookup"><span data-stu-id="e0873-123">To run the tool pass a valid XML file using the following string:</span></span>

    AllJoynCodeGen –i Foo.xml –o c:\users\developer1\documents\Foo\

## <a name="reviewing-the-output"></a><span data-ttu-id="e0873-124">查看输出</span><span class="sxs-lookup"><span data-stu-id="e0873-124">Reviewing the output</span></span>

<span data-ttu-id="e0873-125">生成的类封装核心 C API 公开的功能。</span><span class="sxs-lookup"><span data-stu-id="e0873-125">The generated classes wrap functionality exposed by the Core C API.</span></span> <span data-ttu-id="e0873-126">因为生成的代码是一个抽象概念，所以这不是 1 对 1 映射。</span><span class="sxs-lookup"><span data-stu-id="e0873-126">Because the generated code is an abstraction, this is not a 1-to-1 mapping.</span></span> <span data-ttu-id="e0873-127">下表显示了每个生成的代码类封装的核心 C++ API。</span><span class="sxs-lookup"><span data-stu-id="e0873-127">The table below shows which Core C++ APIs are wrapped by each generated code class.</span></span> <span data-ttu-id="e0873-128">以下占位符用于该表中生成的名称：</span><span class="sxs-lookup"><span data-stu-id="e0873-128">The following placeholders are used for generated names in the table:</span></span>

* `<Foo>` <span data-ttu-id="e0873-129">是 xml 文件中定义的名称</span><span class="sxs-lookup"><span data-stu-id="e0873-129">is the name of the interface defined in the xml file</span></span>
* `<Signal>` <span data-ttu-id="e0873-130">是信号，同时从 xml 文件中获取的名称</span><span class="sxs-lookup"><span data-stu-id="e0873-130">is the name of a signal, taken from the xml file</span></span>
* `<Method>` <span data-ttu-id="e0873-131">是一种方法，从 xml 文件中获取的名称</span><span class="sxs-lookup"><span data-stu-id="e0873-131">is the name of a method, taken from the xml file</span></span>
* `<Property>` <span data-ttu-id="e0873-132">从 xml 文件中获取的属性的名称</span><span class="sxs-lookup"><span data-stu-id="e0873-132">is the name of a property, taken from the xml file</span></span>


> | <span data-ttu-id="e0873-133">Windows 运行时类</span><span class="sxs-lookup"><span data-stu-id="e0873-133">Windows Runtime Class</span></span> |  | <span data-ttu-id="e0873-134">描述</span><span class="sxs-lookup"><span data-stu-id="e0873-134">Description</span></span> | <span data-ttu-id="e0873-135">核心 C++ API</span><span class="sxs-lookup"><span data-stu-id="e0873-135">Core C++ API</span></span> |
> | ------------------------ | --- | --------- | ---------- |
> | `<Foo>`<span data-ttu-id="e0873-136">观察程序</span><span class="sxs-lookup"><span data-stu-id="e0873-136">Watcher</span></span> |  | <span data-ttu-id="e0873-137">搜索宣传目标服务的制造者</span><span class="sxs-lookup"><span data-stu-id="e0873-137">Searches for producers that advertise the target service</span></span> | <span data-ttu-id="e0873-138">*BusListener* 类；*BusAttachment* 类</span><span class="sxs-lookup"><span data-stu-id="e0873-138">*BusListener* class; *BusAttachment* class</span></span> |
> | `<Foo>`<span data-ttu-id="e0873-139">JoinSessionResult</span><span class="sxs-lookup"><span data-stu-id="e0873-139">JoinSessionResult</span></span> |  | <span data-ttu-id="e0873-140">报告加入会话是成功还是失败，并且在成功加入后，公开该会话的 `<Foo>Consumer` 实例。</span><span class="sxs-lookup"><span data-stu-id="e0873-140">Reports the success or failure of joining a session, and exposes a `<Foo>Consumer` instance for the session if the join was successful.</span></span> | <span data-ttu-id="e0873-141">*JoinSessionAsyncCB* 类；*QStatus*</span><span class="sxs-lookup"><span data-stu-id="e0873-141">*JoinSessionAsyncCB* class; *QStatus*</span></span> |
> | `<Foo>`<span data-ttu-id="e0873-142">生成者</span><span class="sxs-lookup"><span data-stu-id="e0873-142">Producer</span></span> |  | <span data-ttu-id="e0873-143">宣传服务并公开 AllJoyn 事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e0873-143">Advertises a service and exposes handlers for AllJoyn events.</span></span> | <span data-ttu-id="e0873-144">*BusObject* 类；*BusAttachment* 类；*InterfaceDescription* 类；*SessionPortListener* 类；*Message* 类</span><span class="sxs-lookup"><span data-stu-id="e0873-144">*BusObject* class; *BusAttachment* class; *InterfaceDescription* class; *SessionPortListener* class; *Message* class</span></span> |
> | `<Foo>`<span data-ttu-id="e0873-145">信号</span><span class="sxs-lookup"><span data-stu-id="e0873-145">Signals</span></span> |  | <span data-ttu-id="e0873-146">公开用于发送和接收信号的方法和处理程序。</span><span class="sxs-lookup"><span data-stu-id="e0873-146">Exposes methods and handlers to send and receive signals.</span></span> <span data-ttu-id="e0873-147">制造者和使用者两者均可使用。</span><span class="sxs-lookup"><span data-stu-id="e0873-147">Used by both producers and consumers.</span></span> | <span data-ttu-id="e0873-148">*BusObject* 类；*InterfaceDescription* 类；*Message* 类</span><span class="sxs-lookup"><span data-stu-id="e0873-148">*BusObject* class; *InterfaceDescription* class; *Message* class</span></span> |
> | `<Foo>`<span data-ttu-id="e0873-149">使用者</span><span class="sxs-lookup"><span data-stu-id="e0873-149">Consumer</span></span> |  | <span data-ttu-id="e0873-150">与发现的服务进行交互。</span><span class="sxs-lookup"><span data-stu-id="e0873-150">Interacts with a service after it has been discovered.</span></span> | <span data-ttu-id="e0873-151">*ProxyBusObject* 类；*InterfaceDescription* 类；*SessionListener* 类；*Message* 类</span><span class="sxs-lookup"><span data-stu-id="e0873-151">*ProxyBusObject* class; *InterfaceDescription* class; *SessionListener* class; *Message* class</span></span> |
> | `<Foo>``<Method>`<span data-ttu-id="e0873-152">CalledEventArgs</span><span class="sxs-lookup"><span data-stu-id="e0873-152">CalledEventArgs</span></span> |  | <span data-ttu-id="e0873-153">传递给 `EventAdapters.<Foo>ServiceEventAdapter` 中方法的参数。</span><span class="sxs-lookup"><span data-stu-id="e0873-153">Arguments passed to methods in `EventAdapters.<Foo>ServiceEventAdapter`.</span></span> | <span data-ttu-id="e0873-154">*Message* 类</span><span class="sxs-lookup"><span data-stu-id="e0873-154">*Message* class</span></span> |
> | `<Foo>``<Method>`<span data-ttu-id="e0873-155">结果</span><span class="sxs-lookup"><span data-stu-id="e0873-155">Result</span></span> |  | <span data-ttu-id="e0873-156">I<Foo>Service 中的方法实现用它来报告调用是成功还是失败，以及报告任何返回值。</span><span class="sxs-lookup"><span data-stu-id="e0873-156">Used by method implementations in I<Foo>Service to report the success or failure of the call, as well as any return values.</span></span> | <span data-ttu-id="e0873-157">*Message* 类；*QStatus*</span><span class="sxs-lookup"><span data-stu-id="e0873-157">*Message* class; *QStatus*</span></span> |
> | `<Foo>``<Signal>`<span data-ttu-id="e0873-158">ReceivedEventArgs</span><span class="sxs-lookup"><span data-stu-id="e0873-158">ReceivedEventArgs</span></span> |  | <span data-ttu-id="e0873-159">传递给 <Foo>Signal 中信号的参数。</span><span class="sxs-lookup"><span data-stu-id="e0873-159">Arguments passed to a signal in <Foo>Signals.</span></span> | <span data-ttu-id="e0873-160">*Message* 类</span><span class="sxs-lookup"><span data-stu-id="e0873-160">*Message* class</span></span> |


## <a name="build-guide"></a><span data-ttu-id="e0873-161">生成指南</span><span class="sxs-lookup"><span data-stu-id="e0873-161">Build guide</span></span>

#### <a name="creating-the-component"></a><span data-ttu-id="e0873-162">创建组件</span><span class="sxs-lookup"><span data-stu-id="e0873-162">Creating the component</span></span>

<span data-ttu-id="e0873-163">生成的代码需要包含在与 XML 共享相同接口名称的组件中。</span><span class="sxs-lookup"><span data-stu-id="e0873-163">The generated code needs to be contained in a component that shares the same interface name as the XML.</span></span> <span data-ttu-id="e0873-164">例如，如果将某个 toaster 的 XML 定义为 com.microsoft.sample.toaster，我们将创建运行时组件 com.microsoft.sample。</span><span class="sxs-lookup"><span data-stu-id="e0873-164">For example, if the XML for a toaster is defined as com.microsoft.sample.toaster, we would create a runtime component com.microsoft.sample.</span></span> 

<span data-ttu-id="e0873-165">或者，可以随意命名组件（例如，fooCodeGenComponent），但必须手动将“项目”属性下的根命名空间更新为与接口名称相同的名称。</span><span class="sxs-lookup"><span data-stu-id="e0873-165">Alternatively, you can name the component whatever you want (e.g. fooCodeGenComponent), but you must manually update the root namespace under the Project properties to be the same as the interface name.</span></span>

> [!TIP]
> <span data-ttu-id="e0873-166">可以从 AllJoynCodeGen 工具生成的 pch.h 文件中找到的根命名空间。</span><span class="sxs-lookup"><span data-stu-id="e0873-166">You can find the root namespace in the pch.h file that is generated from the AllJoynCodeGen tool.</span></span>
