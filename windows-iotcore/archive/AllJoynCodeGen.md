---
title: AllJoynCodeGen 概述
author: saraclay
ms.author: saclayt
ms.date: 09/06/17
ms.topic: article
ms.prod: windows-iot
ms.technology: IoT
description: 了解 AllJoynCodeGen, 它是一种代码生成工具, 可使用 AllJoyn 接口生成完整的 Windows 运行时组件。
keywords: windows iot, AllJoyn
ms.openlocfilehash: c8e9f08c5565c7e4252e1b15858c08402eedb712
ms.sourcegitcommit: 2b4ce105834c294dcdd8f332ac8dd2732f4b5af8
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "60167739"
---
> [!NOTE]
> <span data-ttu-id="ce294-104">你正在查看存档的文档。</span><span class="sxs-lookup"><span data-stu-id="ce294-104">You are viewing archived documentation.</span></span> <span data-ttu-id="ce294-105">Windows 10 IoT 不再支持 AllJoyn。</span><span class="sxs-lookup"><span data-stu-id="ce294-105">AllJoyn is no longer supported by Windows 10 IoT.</span></span> <span data-ttu-id="ce294-106">如有问题, 请在 GitHub 上提出问题, 或在下面的评论中留下反馈。</span><span class="sxs-lookup"><span data-stu-id="ce294-106">For questions, please open an issue on GitHub or leave us feedback in the comments below.</span></span>

# <a name="alljoyncodegen-overview"></a><span data-ttu-id="ce294-107">AllJoynCodeGen 概述</span><span class="sxs-lookup"><span data-stu-id="ce294-107">AllJoynCodeGen Overview</span></span>

<span data-ttu-id="ce294-108">我们创建了代码生成工具 AllJoynCodeGen，该工具可使用派生自某种规范或某台设备的一个或多个 AllJoyn 接口的 XML 描述生成完整的 Windows 运行时组件。</span><span class="sxs-lookup"><span data-stu-id="ce294-108">We've created a code generation tool, AllJoynCodeGen, that generates a complete Windows Runtime component using an XML description of one or more AllJoyn interfaces derived from a specification or device.</span></span>

<span data-ttu-id="ce294-109">由此工具生成的 Windows 运行时组件通过使用通用 Windows SDK 中提供的 API，可在任何受支持的语言（JS、C#、C++/CX 等）中使用。</span><span class="sxs-lookup"><span data-stu-id="ce294-109">The Windows Runtime component generated by this tool can be consumed in any supported language (JS, C#, C++/CX, etc.) using APIs that are available in the Universal Windows SDK.</span></span> <span data-ttu-id="ce294-110">这表示相同的组件可在具有 AllJoyn OneCore 程序包（路由器服务和 C API dll）的任何平台上使用。然后，开发人员可使用该组件创建该接口的制造者和/或使用者。</span><span class="sxs-lookup"><span data-stu-id="ce294-110">This means that the same component can be used on any platform that has the AllJoyn OneCore package (router service and C API dll.) A developer can then use the component to create a producer and/or a consumer of that interface.</span></span> 

<span data-ttu-id="ce294-111">**注意** 有关 AllJoyn C Api 的更多详细信息, 可以在[AllSeen 联盟](http://go.microsoft.com/fwlink/?LinkId=524584)中下载 ALLJOYN Core SDK 和文档。</span><span class="sxs-lookup"><span data-stu-id="ce294-111">**Note**  For more details about the AllJoyn C APIs, you can download the AllJoyn Core SDK and documentation at [The AllSeen Alliance](http://go.microsoft.com/fwlink/?LinkId=524584).</span></span>

## <a name="how-does-alljoyncodegen-work"></a><span data-ttu-id="ce294-112">AllJoynCodeGen 是如何工作的？</span><span class="sxs-lookup"><span data-stu-id="ce294-112">How does AllJoynCodeGen work?</span></span>

<span data-ttu-id="ce294-113">基本流程如下所示：</span><span class="sxs-lookup"><span data-stu-id="ce294-113">The basic flow is as follows:</span></span>

1. <span data-ttu-id="ce294-114">以 AllJoyn XML 编写（当前为 DBus 内省格式）、描述服务的 XML 文件会被送入代码生成器工具中。</span><span class="sxs-lookup"><span data-stu-id="ce294-114">An XML file authored in the AllJoyn XML (currently DBus introspection format) that describes the service is fed into the codegen tool.</span></span>
2. <span data-ttu-id="ce294-115">AllJoynCodeGen 工具将生成结果为 Windows 运行时组件的代码。</span><span class="sxs-lookup"><span data-stu-id="ce294-115">The AllJoynCodeGen tool generates code that results in a Windows Runtime component.</span></span> <span data-ttu-id="ce294-116">此生成的代码依赖于 Windows 10 SDK 中的 **MSAJAPI.lib** 和 [Windows.Devices.AllJoyn](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.alljoyn.aspx)。</span><span class="sxs-lookup"><span data-stu-id="ce294-116">This generated code relies on **MSAJAPI.lib** and [Windows.Devices.AllJoyn](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.alljoyn.aspx) from the Windows 10 SDK.</span></span>
3. <span data-ttu-id="ce294-117">开发人员可生成使用此组件的应用程序。</span><span class="sxs-lookup"><span data-stu-id="ce294-117">The developer builds an application that consumes this component.</span></span>
4. <span data-ttu-id="ce294-118">运行时，开发人员的应用程序将加载该工具生成的 Windows 运行时组件（例如：foo.dll）以及内置 DLL **MSAJAPI.dll** 和 **Windows.Devices.AllJoyn.dll**。</span><span class="sxs-lookup"><span data-stu-id="ce294-118">At runtime, the developer's application will load the Windows Runtime component generated by the tool (e.g.: foo.dll,) as well as the in-box DLLs **MSAJAPI.dll** and **Windows.Devices.AllJoyn.dll**.</span></span>

<span data-ttu-id="ce294-119">以下工作流图表说明了这一过程：</span><span class="sxs-lookup"><span data-stu-id="ce294-119">The following workflow diagram illustrates this process:</span></span>

![AllJoyn CodeGen 图](../media/AllJoyn/alljoyncodegen.png)

## <a name="running-from-the-command-line"></a><span data-ttu-id="ce294-121">从命令行运行</span><span class="sxs-lookup"><span data-stu-id="ce294-121">Running from the command line</span></span>

<span data-ttu-id="ce294-122">AllJoynCodeGen 工具当前作为随 Windows 10 SDK 提供的命令行工具的形式存在。</span><span class="sxs-lookup"><span data-stu-id="ce294-122">The AllJoynCodeGen tool currently exists as a command line tool shipped with the Windows 10 SDK.</span></span> <span data-ttu-id="ce294-123">若要运行该工具，请使用以下字符串传递有效的 XML 文件：</span><span class="sxs-lookup"><span data-stu-id="ce294-123">To run the tool pass a valid XML file using the following string:</span></span>

    AllJoynCodeGen –i Foo.xml –o c:\users\developer1\documents\Foo\

## <a name="reviewing-the-output"></a><span data-ttu-id="ce294-124">查看输出</span><span class="sxs-lookup"><span data-stu-id="ce294-124">Reviewing the output</span></span>

<span data-ttu-id="ce294-125">生成的类封装核心 C API 公开的功能。</span><span class="sxs-lookup"><span data-stu-id="ce294-125">The generated classes wrap functionality exposed by the Core C API.</span></span> <span data-ttu-id="ce294-126">因为生成的代码是一个抽象概念，所以这不是 1 对 1 映射。</span><span class="sxs-lookup"><span data-stu-id="ce294-126">Because the generated code is an abstraction, this is not a 1-to-1 mapping.</span></span> <span data-ttu-id="ce294-127">下表显示了每个生成的代码类封装的核心 C++ API。</span><span class="sxs-lookup"><span data-stu-id="ce294-127">The table below shows which Core C++ APIs are wrapped by each generated code class.</span></span> <span data-ttu-id="ce294-128">以下占位符用于该表中生成的名称：</span><span class="sxs-lookup"><span data-stu-id="ce294-128">The following placeholders are used for generated names in the table:</span></span>

* <span data-ttu-id="ce294-129">`<Foo>` 是 XML 文件中定义的接口名称</span><span class="sxs-lookup"><span data-stu-id="ce294-129">`<Foo>` is the name of the interface defined in the xml file</span></span>
* <span data-ttu-id="ce294-130">`<Signal>` 是信号的名称，取自 XML 文件</span><span class="sxs-lookup"><span data-stu-id="ce294-130">`<Signal>` is the name of a signal, taken from the xml file</span></span>
* <span data-ttu-id="ce294-131">`<Method>` 是方法的名称，取自 XML 文件</span><span class="sxs-lookup"><span data-stu-id="ce294-131">`<Method>` is the name of a method, taken from the xml file</span></span>
* <span data-ttu-id="ce294-132">`<Property>` 是属性的名称，取自 XML 文件</span><span class="sxs-lookup"><span data-stu-id="ce294-132">`<Property>` is the name of a property, taken from the xml file</span></span>


> | <span data-ttu-id="ce294-133">Windows 运行时类</span><span class="sxs-lookup"><span data-stu-id="ce294-133">Windows Runtime Class</span></span> |  | <span data-ttu-id="ce294-134">描述</span><span class="sxs-lookup"><span data-stu-id="ce294-134">Description</span></span> | <span data-ttu-id="ce294-135">核心 C++ API</span><span class="sxs-lookup"><span data-stu-id="ce294-135">Core C++ API</span></span> |
> | ------------------------ | --- | --------- | ---------- |
> | <span data-ttu-id="ce294-136">`<Foo>`观察程序</span><span class="sxs-lookup"><span data-stu-id="ce294-136">`<Foo>`Watcher</span></span> |  | <span data-ttu-id="ce294-137">搜索宣传目标服务的制造者</span><span class="sxs-lookup"><span data-stu-id="ce294-137">Searches for producers that advertise the target service</span></span> | <span data-ttu-id="ce294-138">*BusListener* 类；*BusAttachment* 类</span><span class="sxs-lookup"><span data-stu-id="ce294-138">*BusListener* class; *BusAttachment* class</span></span> |
> | <span data-ttu-id="ce294-139">`<Foo>`JoinSessionResult</span><span class="sxs-lookup"><span data-stu-id="ce294-139">`<Foo>`JoinSessionResult</span></span> |  | <span data-ttu-id="ce294-140">报告加入会话是成功还是失败，并且在成功加入后，公开该会话的 `<Foo>Consumer` 实例。</span><span class="sxs-lookup"><span data-stu-id="ce294-140">Reports the success or failure of joining a session, and exposes a `<Foo>Consumer` instance for the session if the join was successful.</span></span> | <span data-ttu-id="ce294-141">*JoinSessionAsyncCB* 类；*QStatus*</span><span class="sxs-lookup"><span data-stu-id="ce294-141">*JoinSessionAsyncCB* class; *QStatus*</span></span> |
> | <span data-ttu-id="ce294-142">`<Foo>`制造者</span><span class="sxs-lookup"><span data-stu-id="ce294-142">`<Foo>`Producer</span></span> |  | <span data-ttu-id="ce294-143">宣传服务并公开 AllJoyn 事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="ce294-143">Advertises a service and exposes handlers for AllJoyn events.</span></span> | <span data-ttu-id="ce294-144">*BusObject* 类；*BusAttachment* 类；*InterfaceDescription* 类；*SessionPortListener* 类；*Message* 类</span><span class="sxs-lookup"><span data-stu-id="ce294-144">*BusObject* class; *BusAttachment* class; *InterfaceDescription* class; *SessionPortListener* class; *Message* class</span></span> |
> | <span data-ttu-id="ce294-145">`<Foo>`信号</span><span class="sxs-lookup"><span data-stu-id="ce294-145">`<Foo>`Signals</span></span> |  | <span data-ttu-id="ce294-146">公开用于发送和接收信号的方法和处理程序。</span><span class="sxs-lookup"><span data-stu-id="ce294-146">Exposes methods and handlers to send and receive signals.</span></span> <span data-ttu-id="ce294-147">制造者和使用者两者均可使用。</span><span class="sxs-lookup"><span data-stu-id="ce294-147">Used by both producers and consumers.</span></span> | <span data-ttu-id="ce294-148">*BusObject* 类；*InterfaceDescription* 类；*Message* 类</span><span class="sxs-lookup"><span data-stu-id="ce294-148">*BusObject* class; *InterfaceDescription* class; *Message* class</span></span> |
> | <span data-ttu-id="ce294-149">`<Foo>`使用者</span><span class="sxs-lookup"><span data-stu-id="ce294-149">`<Foo>`Consumer</span></span> |  | <span data-ttu-id="ce294-150">与发现的服务进行交互。</span><span class="sxs-lookup"><span data-stu-id="ce294-150">Interacts with a service after it has been discovered.</span></span> | <span data-ttu-id="ce294-151">*ProxyBusObject* 类；*InterfaceDescription* 类；*SessionListener* 类；*Message* 类</span><span class="sxs-lookup"><span data-stu-id="ce294-151">*ProxyBusObject* class; *InterfaceDescription* class; *SessionListener* class; *Message* class</span></span> |
> | <span data-ttu-id="ce294-152">`<Foo>``<Method>`CalledEventArgs</span><span class="sxs-lookup"><span data-stu-id="ce294-152">`<Foo>``<Method>`CalledEventArgs</span></span> |  | <span data-ttu-id="ce294-153">传递给 `EventAdapters.<Foo>ServiceEventAdapter` 中方法的参数。</span><span class="sxs-lookup"><span data-stu-id="ce294-153">Arguments passed to methods in `EventAdapters.<Foo>ServiceEventAdapter`.</span></span> | <span data-ttu-id="ce294-154">*Message* 类</span><span class="sxs-lookup"><span data-stu-id="ce294-154">*Message* class</span></span> |
> | <span data-ttu-id="ce294-155">`<Foo>``<Method>`结果</span><span class="sxs-lookup"><span data-stu-id="ce294-155">`<Foo>``<Method>`Result</span></span> |  | <span data-ttu-id="ce294-156">I<Foo>Service 中的方法实现用它来报告调用是成功还是失败，以及报告任何返回值。</span><span class="sxs-lookup"><span data-stu-id="ce294-156">Used by method implementations in I<Foo>Service to report the success or failure of the call, as well as any return values.</span></span> | <span data-ttu-id="ce294-157">*Message* 类；*QStatus*</span><span class="sxs-lookup"><span data-stu-id="ce294-157">*Message* class; *QStatus*</span></span> |
> | <span data-ttu-id="ce294-158">`<Foo>``<Signal>`ReceivedEventArgs</span><span class="sxs-lookup"><span data-stu-id="ce294-158">`<Foo>``<Signal>`ReceivedEventArgs</span></span> |  | <span data-ttu-id="ce294-159">传递给 <Foo>Signal 中信号的参数。</span><span class="sxs-lookup"><span data-stu-id="ce294-159">Arguments passed to a signal in <Foo>Signals.</span></span> | <span data-ttu-id="ce294-160">*Message* 类</span><span class="sxs-lookup"><span data-stu-id="ce294-160">*Message* class</span></span> |


## <a name="build-guide"></a><span data-ttu-id="ce294-161">生成指南</span><span class="sxs-lookup"><span data-stu-id="ce294-161">Build guide</span></span>

#### <a name="creating-the-component"></a><span data-ttu-id="ce294-162">创建组件</span><span class="sxs-lookup"><span data-stu-id="ce294-162">Creating the component</span></span>

<span data-ttu-id="ce294-163">生成的代码需要包含在与 XML 共享相同接口名称的组件中。</span><span class="sxs-lookup"><span data-stu-id="ce294-163">The generated code needs to be contained in a component that shares the same interface name as the XML.</span></span> <span data-ttu-id="ce294-164">例如，如果将某个 toaster 的 XML 定义为 com.microsoft.sample.toaster，我们将创建运行时组件 com.microsoft.sample。</span><span class="sxs-lookup"><span data-stu-id="ce294-164">For example, if the XML for a toaster is defined as com.microsoft.sample.toaster, we would create a runtime component com.microsoft.sample.</span></span> 

<span data-ttu-id="ce294-165">或者，可以随意命名组件（例如，fooCodeGenComponent），但必须手动将“项目”属性下的根命名空间更新为与接口名称相同的名称。</span><span class="sxs-lookup"><span data-stu-id="ce294-165">Alternatively, you can name the component whatever you want (e.g. fooCodeGenComponent), but you must manually update the root namespace under the Project properties to be the same as the interface name.</span></span>

> [!TIP]
> <span data-ttu-id="ce294-166">可以在通过 AllJoynCodeGen 工具生成的 pch 文件中找到根命名空间。</span><span class="sxs-lookup"><span data-stu-id="ce294-166">You can find the root namespace in the pch.h file that is generated from the AllJoynCodeGen tool.</span></span>
